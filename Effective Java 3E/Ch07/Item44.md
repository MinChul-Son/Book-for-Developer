# 아이템 44. 표준 함수형 인터페이스를 사용하라

**만약 표준 함수형 인터페이스에 필요한 용도에 맞는 것이 존재한다면 직접 구현하지 말자!**

`API`가 다루는 개념의 수가 줄어들어 익히기 더 쉬워지고 표준 함수형 인터페이스에서 제공하는 디폴트 메서드를 통해 상호 운용성이 좋아진다.


<br>

## Operator
인수가 1개인 `UnaryOperator`와 2개인 `BinaryOperator`로 나뉜다.

<br>

## Predicate
인수 하나를 받아 `boolean`을 반환하는 함수를 뜻한다.

<br>

## Function
인수와 반환 타입이 다른 함수를 뜻한다.

<br>

## Supplier
인수를 받지 않고 값을 반환(제공)하는 함수를 뜻한다.

<br>

## Consumer
인수를 하나 받고 반환값은 없는(인수를 소비하는) 함수를 뜻한다.

<br>

참고로, 표준 함수형 인터페이스 대부분은 기본 타입만 지원한다.

따라서, 표준 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말자 -> 성능 이슈!!


---

## 직접 함수형 인터페이스를 구현해야하는 상황
- 자주 쓰이면서 이름 자체가 용도를 명확히 설명해줌
- 반드시 따라야하는 규약이 있음
- 유용한 디폴트 메서드를 제공할 수 있음
- ex: `Comparator`


### 직접 만든 함수형 인터페이스에는 @FunctionalInterface를 반드시 사용하라
1. 해당 클래스의 코드나 문서를 읽는 사람에게 이것이 람다용으로 설계되었음을 알려줌
2. 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일됨
3. 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아줌

<br>


---

## 함수형 인터페이스를 API에서 사용할 때 주의할 점
- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의하면 안됨
  - 불필요한 모호함만 안겨주고 문제가 발생함
