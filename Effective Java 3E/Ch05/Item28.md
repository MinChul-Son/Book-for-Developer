# 아이템 28 : 배열보다는 리스트를 사용하라


## 공변
배열과 제네릭 타입의 가장 큰 차이점은 **공변**이다.

배열에서는 `Super`와 그의 자식 `Sub`가 있을 때 `Sub[]`도 `Super[]`의 자식이다.

하지만 제네릭은 그렇지 않다.

<br>

## 실체화(reify)
배열은 런타임에도 삽입하려는 원소의 타입을 인지하고 확인한다.

하지만, 제네릭은 타입 정보가 런타임에는 모두 사라지기 때문에 컴파일 시점에만 체크한다.

<br>

## 제네릭 배열??
배열과 제네릭은 어우러지지 못한다.

배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
- `new List<E>[]`, `new List<Sring>[]`, `new E[]`는 컴파일 오류

제네릭 배열은 `Type Safe`하지 않기 때문에 허용하지 않았다.

컴파일러의 형변환 코드에서 런타임 시점에 `ClassCastException`이 발생할 수 있다.
- 제네릭의 이점을 없애버림

<br>

## 실체화 불가 타입
`E`, `List<E>`, `List<String>`같은 타입을 **실체화 불가 타입**이라한다.

실체화되지 않아 런타임에 컴파일타임보다 타입 정보를 적게 가지는 타입을 뜻한다.

`List<String>`과 `List<Integer>`가 존재한다고 생각해보자.

이는 컴파일 시점에 타입에 대한 정보가 소거되고 런타임 시점에는 동일하게 `List`이다.

이러한 타입은 **런타임 시점에 모든 정보를 사용할 수 없으므로 실체화 불가 타입**이라 부른다.

반대로, `List<?>`같은 **비한정적 와일드카드 타입은 모두 실체화 타입**이다.

[공식문서 참조](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html)

<br>

## 제네릭 타입과 가변인수 메서드
가변인수 메서드는 가변적인 파라미터를 받을 수 있는 메서드를 의미한다.

호출될 때마다 파라미터를 담을 배열을 생성하게 되는데 그 원소가 실체화 불가 타입이라는 경고가 발생한다.
- `@SafeVarargs`를 사용하여 대체할 수 있다.

<br>

#### 비검사 형변환 경고, 제네릭 배열 생성 오류를 제거하려면 배열 대신 리스트를 사용하면 대부분 해결할 수 있다.

#### 조금 복잡해지고 성능이 조금 나빠질 수는 있지만 `Type Safe`와 상호 운용성을 얻을 수 있다.
