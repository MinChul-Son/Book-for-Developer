# 4장 커넥션 관리

## 목차
- HTTP는 어떻게 TCP 커넥션을 사용하는가?
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

<br>
<br>

-----------------------------------------------

## TCP 커넥션
`TCP 커넥션`이 맺어지면 주고받는 데이터들은 손실, 손상되지 않고 순서대로 전달

![image](https://user-images.githubusercontent.com/60773356/136761343-84629c55-b8f2-47c4-ae88-859d30d798ce.png)

우리가 아는 `3-Way-Handshake`는 바로 (4)에서 `TCP 커넥션`을 맺으며 수행

이 맺어진 커넥션을 통해 통신(Request와 Response)을 하게되고 통신이 완료된 후 커넥션은 `close`

이 때, 흔히 얘기하는 데이터는 `IP 패킷`, `IP 데이터그램`을 통해 전송

![image](https://user-images.githubusercontent.com/60773356/136762260-0f7240e4-2199-475d-929b-61d42f4fb014.png)
* 여기서 A, B, C가 각각 하나의 패킷이다.

#### 하나의 큰 덩어리 데이터를 작은 패킷단위로 나누어 쪼개는 이유는 뭘까?
효율적인 라우팅을 위해서!!

순서 보장을 위해 각 패킷에 일련의 순서를 배정한 뒤 발신지에서 발송을 하게되고, 수신지에서는 이 패킷을 재조립하게 되는데 이 일련의 순서를 보고 재조립을 하여 순서를 보장할 수 있게 된다.

### TCP 패킷(세그먼트)
![image](https://user-images.githubusercontent.com/60773356/136762920-12d03420-675e-4429-8a75-731fe249f844.png)
- Source Port, Destination Port : 송, 수신 포트 번호
- Sequence Number : 데이터의 순서번호를 표시
등등

### TCP 커넥션 생성
**`<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>`**

이 4가지 값으로 `TCP 커넥션`을 생성하는데 모든 값이 같은 커넥션은 존재할 수 없다.(유일무이)

### TCP 소켓 프로그래밍
Java의 Socket API를 사용해 간단히 구현해보자.

- 서버

![image](https://user-images.githubusercontent.com/60773356/136785341-1f4a9d26-0d18-4c07-89c2-e150ee68b9bd.png)
![image](https://user-images.githubusercontent.com/60773356/136785435-49dbc6a5-cb6f-4383-bf40-b96c7450777b.png)


- 클라이언트

![image](https://user-images.githubusercontent.com/60773356/136785376-d355e15f-5350-4a0e-bfe5-636a9ad90795.png)
![image](https://user-images.githubusercontent.com/60773356/136785456-c850b0f6-00ab-42d8-9d7c-33db4cb8316a.png)

<br>
<br>

-----------------------------------------------

## TCP의 성능
**HTTP 트랜잭션의 성능은 TCP 에 영향을 받음**
- 도메인으로부터 IP 주소를 알아내는 과정
- 서버와 클라이언트간에 TCP 커넥션을 맺는 과정
- 클라이언트가 요청을 전송하는 과정
- 서버에서 응답을 전송하는 과정

대부분의 HTTP 지연은 TCP 네트워크 지연으로 인해 발생!!

<br>

### TCP 커넥션 핸드셰이크 지연
1. 클라이언트가 서버에게 `SYN`전달(커넥션 요청)
2. 서버가 클라이언트에게 `SYN`과 `ACK`전달(커넥션 요청이 받아들여졌고 반대로 커넥션 요청)
3. 클라이언트가 서버로 'ACK`와 전송할 데이터를 전송
4. 서버가 응답을 전송

TCP의 ACK 패킷은 크고, 무겁다.(생성 비용이 비싸다) 

즉, 전송할 데이터의 크기가 작은데 이런 비싼 커넥션을 생성한다면 지연이 발생한다.(크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP 구성에 쓴다.)

`Connection Pool`, `Thread Pool`처럼 재사용할 수는 없을까??

<br>

### 확인응답 지연
`TCP`의 특징은 데이터의 손실, 손상을 방지하고 순서를 보장하는 신뢰성있는 전송 프로토콜이다.

이를 위해 `Sequence Number`와 `Checksum`을 통해 순번과 데이터의 무결성을 체크한다.
- `Checksum`을 통해 해싱과 같은 역할

데이터를 체크하고 만약 제대로 받았다면 수신측에서 송신측으로 확인응답패킷를 반환한다.

송신측에서 이를 받지 못했다면 패킷이 손상, 파기되었거나 문제가 있는 것으로 판단하여 다시 전송하는데, 확인응답패킷은 크기가 작다.

효율적인 전송을 위해 같은 방향으로 송출되는 데이터 패킷에 편승시켜 반환해준다.

한번에 더 많은 확인응답패킷을 편승시키기위해 확인응답지연 알고리즘을 사용하는데, 일정 시간동안 편승시킬 패킷을 찾고 찾지못하면 새로 패킷을 만들어 전송한다.

HTTP 통신은 요청과 응답 두가지로만 이루어지기 때문에 편승될 기회가 많이 없으므로 이로 인한 지연이 발생한다.

> 송신측에서는 수신측의 확인응답패킷을 기다리게되고 수신측에서는 데이터를 정상적으로 수신했지만 편승시킬 패킷을 찾기위해 대기 ==> **지연 발생**

<br>

### TCP 느린 시작
**TCP 커넥션은 시간이 자나며 자체적으로 튜닝이 된다!!!**

인터넷의 갑작스러운 부하와 혼잡을 방지하기 위한 방법으로 초기에 `TCP`가 전송할 수 있는 패킷의 수를 제한하고 정상적으로 전송을 했을 시에 더 많은 패킷을 전송할 수 있게 해준다.

따라서, **방금 막 생성된 TCP 커넥션**은 **여러번 데이터를 주고 받은 TCP 커넥션**보다 속도가 느리다.

4개의 패킷을 보내게 되는 것을 **혼잡 윈도를 연다**라고 표현한다.

무조건 재사용을 해야겠네 그럼??

<br>

### 네이글(Nagle) 알고리즘과 TCP_NODELAY
네이글 알고리즘은 확인응답지연 알고리즘과 비슷한 메커니즘이다.

데이터가 작아도 `TCP 세그먼트(패킷)`의 크기가 크기 때문에 작은 데이터를 여러개 보내면 네트워크의 성능은 떨어질 수 밖에 없다.

따라서, 세그먼트가 최대 크기가 될 때 까지는 전송을 하지 않고 버퍼에 저장해둔다.

다만, 다른 모든 패킷이 확인 응답을 받았을 경우에는 최대 크기보다 작더라도 전송을 허용해준다.

책에서 말하고 있듯이 네이글 알고리즘이 확인응답지연과 함께 쓰일 경우 형편없이 동작한다. 

네이글 알고리즘은 패킷이 최대 크기가 되거나 모든 확인응답을 기다리는데 확인응답지연이 이를 지연시키기 때문이다.(지연+지연=?)

`TCP_NODELAY`를 HTTP 스택에 설정해 네이글 알고리즘을 비활성화 할 수 있다.(주의가 필요!)

![image](https://user-images.githubusercontent.com/60773356/136920992-f388db37-f8a2-42c1-8965-d076332d6b7f.png)


<br>

### TIME_WAIT의 누적과 포트 고갈
TCP 커넥션이 끊어지면 종단에서 커넥션의 IP주소, 포트번호를 기록해놓는다.

이는 동일한 커넥션이 생성되어 패킷의 충돌을 막기위한 조치이지만, 최근에는 빠른 라우터 덕분에 중복되는 패킷이나 충돌이 발생할 가능성이 없어졌다고 한다.

하지만 성능 측성을 위한 서버에서는 이러한 `TIME_WAIT`로 인한 문제가 발생할 수 있다.

클라이언트 IP, 서버 IP, 서버 포트가 고정되어있고 클라이언트의 포트만을 변경하여 유일한 커넥션을 생성해야하기 때문!!

<br>
<br>

-----------------------------------

## HTTP 커넥션 관리
HTTP는 클라이언트와 서버 사이에 중개 서버(프락시 서버, 캐시 서버)가 놓이는 것을 허용하므로 HTTP 메서지는 중개 서버들을 거치며 전달

두 개의 인접한 HTTP 애플리케이션의 커넥션에만 적용될 옵션을 지정해야할 때는 **HTTP Connection 헤더 필드**를 사용하자!!
- 다른 커넥션으로 전달되지 않는다.
- ex : `Connection:close`, `Connection:keep-alive`
- 비표준 옵션 : keep-alive

`Connection`헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야함!!(hop-by-hop)

1. Connection 헤더와 메시지 수신
2. 송신자의 요청에 있는 모든 옵션 적용
3. 다음 hop으로 전달하기 전에 Connection 헤더에 기술되어 있는 모든 헤더 삭제
4. 다음 hop으로 전달

### hop-by-hop 헤더
- Proxy-Authenticate : 프록시 서버 뒤에 있는 리소스에 엑세스하는데 사용해야하는 인증 방법을 정의(6장 프락시에서 자세하게 다룰 예정)
- Proxy-Connection : 클라이언트와 프락시 사이의 커넥션 옵션을 명시하기 위해 사용
- Transfer-Encoding : 메시지 본문에 적용된 인코딩의 목록
- Upgrade : 메시지를 발송하는 사람이 다른 프로토콜을 사용하는 의사를 전달하기 위해 사용
  - ex: http/1.1을 사용하는 클라이언트가 http/1.0을 사용하는 서버에게 요청을 보낼 수 있도록

<br>

### 순차적인 트랜잭션 처리에 의한 지연
각각의 트랜잭션이 순차적으로 처리되고 트랜잭션 당 커넥션이 생성된다면 커넥션을 맺는데 발생하는 지연(3-way handshake), 느린 시작 지연이 발생

`HTTP Connection`의 성능을 향상시킬 수 있는 기술들
- 병렬 커넥션
- 지속 커넥션
- 파이프라인 커넥션
- 다중 커넥션

<br>
<br>

-----------------------------------------------

## 병렬 커넥션
![image](https://user-images.githubusercontent.com/60773356/136928373-706062e8-401f-4588-9687-6ce5a45fe372.png)
- 각 커넥션의 지연 시간을 겹치게 하여 총 지연 시간을 줄일 수 있음
- 대역폭 : 주어진 경로를 통한 데이터 전송의 최대속도(쉽게 말해 인터넷 속도)
- 따라서, 대역폭이 좁으면 병렬 커넥션의 장점이 사라진다.
- 다수의 커넥션은 메모리를 많이 소모, 자체적인 성능 문제
- 각 클라이언트마다 제한된 병렬 커넥션을 허용
- 실제로 빠르게 내려받지 않더라도 한번에 여러 객체가 보이기 때문에 더 빠르게 느껴질 수도 있다

<br>
<br>

-----------------------------------------------

## 지속 커넥션
한 웹페이지에 첨부된 이미지, 하이버 링크는 같은 사이트에 있으며 같은 사이트를 가르킨다. 이를 `사이트 지역성`이라고 한다.

앞서 살펴본 커넥션들은 트랜잭션 이후에 커넥션을 `close`하지만 **지속 커넥션은 종단(서버 or 클라이언트)에서 끊기 전까지는 커넥션을 유지**한다!!

#### 재사용을 통한 비용 절약, 튜닝된 TCP 커넥션 사용(느린 시작)하여 빠른 전송

<br>

### 지속 커넥션의 장점
- 커넥션을 맺기 위한 비용과 지연을 줄임
- 튜닝된 커넥션 사용
- 커넥션의 수를 줄임(메모리 소모 줄임)

#### 하지만, 잘못 관리하면 연결된 상태로 커넥션이 쌓임

병렬 커넥션과 지속 커넥션을 함께 사용하면 가장 효율적 ==> 제한된 수의 병렬 커넥션을 맺고 그것을 유지하며 재사용

<br>

### HTTP/1.0+의 Keep-Alive 커넥션
![image](https://user-images.githubusercontent.com/60773356/136933125-7d013702-4020-41cd-aadb-f1387231d6c2.png)

`Keep-Alive`, 지속 커넥션을 사용하게 되면 커넥션을 맺고 끊는 작업이 없기 때문에 시간이 단축

`HTTP/1.1`에서는 `keep-alive`를 사용하지 않기로 하였지만 여러 곳에서 사용되고 있기 때문에 HTTP 애플리케이션은 이를 처리할 수 있어야한다.

<br>

### Keep-Alive 동작
커넥션을 유지하기 위해 요청에 `Connection : Keep-Alive`를 포함시켜 전달하고, 요청을 받은 서버는 같은 헤더를 포함시켜 응답을 반환한다.

만약 요청에 `keep-alive`를 보냈으나 응답에 `keep-alive`가 반환되지 않으면 서버가 지원하지 않는 것이다.

<br>

### Keep-Alive 옵션
항상 `keep-alive` 요청을 따를 필요는 없다. 언제든 요청을 `close`할 수 있음
- timeout : 커넥션이 얼마나 유지될 것인지를 의미
- max : 커넥션이 몇 개의 트랜잭션을 처리할 때까지 유지될 것인지를 의미

```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120 # 5개의 트랜잭션이 처리될 때까지 or 120초 동안 유지
```

<br>

### Keep-Alive 커넥션 제한과 규칙
- `keep-alive` 커넥션을 사용하기 위해서는 `Connection: Keep-Alive` 요청 헤더를 전송해야함
- `Connection: Keep-Alive` 헤더를 모든 메시지에 포함시켜야 계속 유지됨
- `Connection: Keep-Alive` 헤더가 없으면 트랜잭션 후 커넥션을 종료
- 엔티티 본문이 정확한 `Content-Length` 값과 함께 `multipart media type`을 가지거나 `chunked transfer encoding`으로 인코드 되어야함
  - 실제보다 짧은 `Content-Length`가 전달된다면 데이터가 다 전달되지도 않았는데 커넥션이 끊어지는 문제가 발생하지 않을까?
- 중개 서버(프락스, 게이트웨이)는 전달하거나 캐싱하기 전 `Connection` 헤더에 명시된 모든 헤더 필드와 `Connection` 헤더를 제거해야함
- `keep-alive` 커넥션은 `Connection` 헤더를 인식하지 못하는 프락시 서버와는 맺어지면 안됨
- 기술적으로 `HTTP/1.0`을 따르는 기기로부터 받는 모든 `Connection` 헤더 필드는 무시해야함 ==> 뒤에 나오는 멍청한 프락시와 연결되는 내용
  - hang : 프로그램이 수행 중 멈추게 된 상황을 의미 
- 클라이언트는 응답을 모두 받기 전에 커넥션이 끊어지면 요청을 다시 보낼 수 있게 준비되어 있어야함

<br>

### Keep-Alive와 멍청한 프락시
`Proxy`는 `Connection` 헤더를 이해하지 못한다. 따라서 이에 대한 처리 없이 요청 그대로를 다음으로 전달한다.

클라이언트-프락시-서버로 구성되어 있다고 가정해보자.

먼저, 클라이언트가 `keep-alive` 커넥션을 사용하기 위해 `Connection` 헤더를 프락시로 전달한다.
> Connection: Keep-Alive
> 프락시 : 이게 뭐야?? 모르니까 다음 Hop으로 넘기자

여기서 문제가 발생하는데 서버는 프락시로부터 `Connection` 헤더를 받고 프락시가 커넥션을 유지하기를 요청했다고 판단하여 프락시와의 커넥션을 유지한다.

하지만, 프락시는 `keep-alive`에 대해 알지못하므로 응답으로 반환된 `Connection` 헤더를 클라이언트에게 전달하고 서버와의 커넥션이 끊어지기를 대기한다.

서버는 프락시와의 커넥션을 끊지 않기 때문에 여기서 **Hang**이 발생한다. 커넥션 종료를 대기하는 동안 프락시는 클라이언트의 요청을 모두 무시한다.

결국 `Timeout`이 발생할 것이다!

#### 홉별 헤더는 절대로 전달해선 안된다!!

<br>

### Proxy-Connection
모든 헤더를 무조건 전달하는 멍청한 프락시의 문제를 해결하기 위해 **Proxy-Connection**헤더를 사용한다.
- 이는 확장 헤더로써 비표준

**멍청한 프락시**가 `Proxy-Connection` 헤더를 그대로 서버로 전달하더라도 서버는 이를 무시한다.

**영리한 프락시**라면 `Proxy-Connection` 헤더를 보고 클라이언트의 `keep-alive` 요청은 인지하여 이를 `Connection: Keep-Alive`로 변환하여 서버로 전달한다.
- 서버와 영리한 프락시 사이에 `Keep-Alive` 커넥션이 유지


#### 그러나 영리한 프락시 옆에 멍청한 프락시가 존재한다면 다시 문제가 발생
![image](https://user-images.githubusercontent.com/60773356/137080639-ad27128f-11ff-4e71-9f4b-0f86da0d4334.png)
- (a)~(f) 함께 이야기해볼 부분
- (g)~(l) 앞선 멍청한 프락시에서의 문제와 동일한 문제가 발생한다.

문제를 발생하는 프락시는 기저에 있어 **보이지 않는** 경우가 많기 때문에 애플리케이션들이 지속 커넥션을 명확히 구현하는 것이 중요하다.

<br>

### HTTP/1.1의 지속 커넥션
`HTTP/1.1`에서 별도 설정을 하지 않으면 모든 커넥션을 지속 커넥션으로 취급한다. `keep-alive` 커넥션을 지원하지 않음

**트랜잭션 이후 커넥션을 종료하려면 헤더에 `Connection: close`를 명시해야한다!!!**

응답에 `Connection: close` 헤더가 없다면 커넥션을 유지하자는 것으로 인지하면 된다. 

<br>

### 지속 커넥션의 제한과 규칙
- 클라이언트가 요청에 `Connection: close` 헤더를 포함해 보냈으면 그 커넥션으로 추가적인 요청을 보낼 수 없다.
- 클라이언트가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면 마지막 요청에 `Connection: close` 헤더를 보내야한다.
  - 기본이 지속 커넥션이기 때문에 커넥션을 유지하고 있어 메모리 낭비
- 커넥션의 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때만 커넥션을 지속시킬 수 있다.
- `HTTP/1.1` 프락시는 클라이언트와 서버 각각에 별도의 지속 커넥션을 맺고 관리해야한다.
- 오래된 프락시가 `Connection` 헤더를 전달하는 문제가 발생할 수 있기 때문에 `HTTP/1.1` 프락시는 커넥션 관련 기능에 대한 지원 범위를 알고 있을 때만 지속 커넥션을 맺어야한다.
  - 지원하지 않은 `Connection : Keep-Alive`를 전달하는 문제 
- `HTTP/1.1` 기기는 `Connection` 헤더의 값과 상관없이 언제든지 커넥션을 끊을 수 있다.
- `HTTP/1.1` 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야한다. 다시 보내도 문제가 없는 요청이라면 가능한 다시 보내야한다.
- 클라이언트가 응답을 받기 전에 커넥션이 끊어질 상황을 대비해 요청을 다시 보낼 준비가 되어있어야한다.
- 클라이언트는 서버의 과부하 방지를 위해 넉넉잡아 두개의 지속 커넥션을 유지해야한다. N명의 사용자가 서버로 접근하려한다면, 프락시는 약 2N개의 커넥션을 유지해야한다.
  - 커넥션을 생성할 때의 서버 부하를 막기위해 2개 정도의 지속 커넥션을 잡아두고 유지시킨다는 의미라고 생각함

<br>
<br>

-----------------------------------------------

## 파이프라인 커넥션
![image](https://user-images.githubusercontent.com/60773356/137088884-ad82c242-527f-4ae9-83d5-3e84f084d426.png)

여러 개의 요청은 큐에 쌓이고 하나의 요청이 전달되면 바로 다음 요청이 전송된다. 하나의 요청에 대한 응답을 대기하지 않아 성능을 높일 수 있다.

즉, 커넥션에 파이프라인을 설치하여 여러번 호출이 가능하게 만드는 것!!

**제약 사항**
- HTTP 클라이언트는 커넥션이 지속 커넥션인지를 확인한 후에 파이프라인 커넥션을 사용해야함
- HTTP 응답은 요청 순서와 동일하게 반환되어야함
  - TCP 패킷처럼 순서를 보장할 수 있는 장치가 없기 때문
- HTTP 클라이언트는 커넥션이 끊어지더라도 완료되지 않은 요청을 바로 다시 전달할 준비가 되어 있어야한다.
- HTTP 클라이언트는 서버에 변화가 생기는 `POST`같은 요청을 파이프라인을 통해 보내선 안된다.
  - `GET`과 같이 단순 조회를 하는 요청은 서버에 변화를 주지 않으므로 반복해서 보내도 문제가 생기지 않음

![image](https://user-images.githubusercontent.com/60773356/137091711-cd46ea0e-9273-4b4a-b12b-b22585e0e720.png)

<br>
<br>

----------------------------------------

## 커넥션 끊기에 대한 미스테리






















