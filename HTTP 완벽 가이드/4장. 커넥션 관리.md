# 4장 커넥션 관리

## 목차
- HTTP는 어떻게 TCP 커넥션을 사용하는가?
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

<br>
<br>

-----------------------------------------------

## TCP 커넥션
`TCP 커넥션`이 맺어지면 주고받는 데이터들은 손실, 손상되지 않고 순서대로 전달

![image](https://user-images.githubusercontent.com/60773356/136761343-84629c55-b8f2-47c4-ae88-859d30d798ce.png)

우리가 아는 `3-Way-Handshake`는 바로 (4)에서 `TCP 커넥션`을 맺으며 수행

이 맺어진 커넥션을 통해 통신(Request와 Response)을 하게되고 통신이 완료된 후 커넥션은 `close`

이 때, 흔히 얘기하는 데이터는 `IP 패킷`, `IP 데이터그램`을 통해 전송

![image](https://user-images.githubusercontent.com/60773356/136762260-0f7240e4-2199-475d-929b-61d42f4fb014.png)
* 여기서 A, B, C가 각각 하나의 패킷이다.

#### 하나의 큰 덩어리 데이터를 작은 패킷단위로 나누어 쪼개는 이유는 뭘까?
효율적인 라우팅을 위해서!!

순서 보장을 위해 각 패킷에 일련의 순서를 배정한 뒤 발신지에서 발송을 하게되고, 수신지에서는 이 패킷을 재조립하게 되는데 이 일련의 순서를 보고 재조립을 하여 순서를 보장할 수 있게 된다.

### TCP 패킷(세그먼트)
![image](https://user-images.githubusercontent.com/60773356/136762920-12d03420-675e-4429-8a75-731fe249f844.png)
- Source Port, Destination Port : 송, 수신 포트 번호
- Sequence Number : 데이터의 순서번호를 표시
등등

### TCP 커넥션 생성
**`<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>`**

이 4가지 값으로 `TCP 커넥션`을 생성하는데 모든 값이 같은 커넥션은 존재할 수 없다.(유일무이)

### TCP 소켓 프로그래밍
Java의 Socket API를 사용해 간단히 구현해보자.

- 서버

![image](https://user-images.githubusercontent.com/60773356/136785341-1f4a9d26-0d18-4c07-89c2-e150ee68b9bd.png)
![image](https://user-images.githubusercontent.com/60773356/136785435-49dbc6a5-cb6f-4383-bf40-b96c7450777b.png)


- 클라이언트

![image](https://user-images.githubusercontent.com/60773356/136785376-d355e15f-5350-4a0e-bfe5-636a9ad90795.png)
![image](https://user-images.githubusercontent.com/60773356/136785456-c850b0f6-00ab-42d8-9d7c-33db4cb8316a.png)

<br>
<br>

## TCP의 성능
**HTTP 트랜잭션의 성능은 TCP 선응에 영향을 받음**
- 도메인으로부터 IP 주소를 알아내는 과정
- 서버와 클라이언트간에 TCP 커넥션을 맺는 과정
- 클라이언트가 요청을 전송하는 과정
- 서버에서 응답을 전송하는 과정

대부분의 HTTP 지연은 TCP 네트워크 지연으로 인해 발생!!

<br>

### TCP 커넥션 핸드셰이크 지연
1. 클라이언트가 서버에게 `SYN`전달(커넥션 요청)
2. 서버가 클라이언트에게 `SYN`과 `ACK`전달(커넥션 요청이 받아들여졌고 반대로 커넥션 요청)
3. 클라이언트가 서버로 'ACK`와 전송할 데이터를 전송
4. 서버가 응답을 전송

TCP의 ACK 패킷은 크고, 무겁다.(생성 비용이 비싸다) 

즉, 전송할 데이터의 크기가 작은데 이런 비싼 커넥션을 생성한다면 지연이 발생한다.(크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP 구성에 쓴다.)

`Connection Pool`, `Thread Pool`처럼 재사용할 수는 없을까??

<br>

### 확인응답 지연
`TCP`의 특징은 데이터의 손실, 손상을 방지하고 순서를 보장하는 신뢰성있는 전송 프로토콜이다.

이를 위해 `Sequence Number`와 `Checksum`을 통해 순번과 데이터의 무결성을 체크한다.
- `Checksum`을 통해 해싱과 같은 역할

데이터를 체크하고 만약 제대로 받았다면 수신측에서 송신측으로 확인응답패킷를 반환한다.

송신측에서 이를 받지 못했다면 패킷이 손상, 파기되었거나 문제가 있는 것으로 판단하여 다시 전송하는데, 확인응답패킷은 크기가 작다.

효율적인 전송을 위해 같은 방향으로 송출되는 데이터 패킷에 편승시켜 반환해준다.

한번에 더 많은 확인응답패킷을 편승시키기위해 확인응답지연 알고리즘을 사용하는데, 일정 시간동안 편승시킬 패킷을 찾고 찾지못하면 새로 패킷을 만들어 전송한다.

HTTP 통신은 요청과 응답 두가지로만 이루어지기 때문에 편승될 기회가 많이 없으므로 이로 인한 지연이 발생한다.

> 송신측에서는 수신측의 확인응답패킷을 기다리게되고 수신측에서는 데이터를 정상적으로 수신했지만 편승시킬 패킷을 찾기위해 대기 ==> **지연 발생**

<br>

### TCP 느린 시작
**TCP 커넥션은 시간이 자나며 자체적으로 튜닝이 된다!!!**

인터넷의 갑작스러운 부하와 혼잡을 방지하기 위한 방법으로 초기에 `TCP`가 전송할 수 있는 패킷의 수를 제한하고 정상적으로 전송을 했을 시에 더 많은 패킷을 전송할 수 있게 해준다.

따라서, **방금 막 생성된 TCP 커넥션**은 **여러번 데이터를 주고 받은 TCP 커넥션**보다 속도가 느리다.

무조건 재사용을 해야겠네 그럼??

<br>

### 네이글(Nagle) 알고리즘과 TCP_NODELAY
네이글 알고리즘은 확인응답지연 알고리즘과 비슷한 메커니즘이다.

데이터가 작아도 `TCP 세그먼트(패킷)`의 크기가 크기 때문에 작은 데이터를 여러개 보내면 네트워크의 성능은 떨어질 수 밖에 없다.

따라서, 세그먼트가 최대 크기가 될 때 까지는 전송을 하지 않고 버퍼에 저장해둔다.

다만, 다른 모든 패킷이 확인 응답을 받았을 경우에는 최대 크기보다 작더라도 전송을 허용해준다.

책에서 말하고 있듯이 네이글 알고리즘이 확인응답지연과 함께 쓰일 경우 형편없이 동작한다. 

네이글 알고리즘은 패킷이 최대 크기가 되거나 모든 확인응답을 기다리는데 확인응답지연이 이를 지연시키기 때문이다.(지연+지연=?)

`TCP_NODELAY`를 HTTP 스택에 설정해 네이글 알고리즘을 비활성화 할 수 있다.(주의가 필요!)

<br>

### TIME_WAIT의 누적과 포트 고갈
TCP 커넥션이 끊어지면 종단에서 커넥션의 IP주소, 포트번호를 기록해놓는다.

이는 동일한 커넥션이 생성되어 패킷의 충돌을 막기위한 조치이지만, 최근에는 빠른 라우터 덕분에 중복되는 패킷이나 충돌이 발생할 가능성이 없어졌다고 한다.

하지만 성능 측성을 위한 서버에서는 이러한 `TIME_WAIT`로 인한 문제가 발생할 수 있다.

클라이언트 IP, 서버 IP, 서버 포트가 고정되어있고 클라이언트의 포트만을 변경하여 유일한 커넥션을 생성해야하기 때문!!

<br>
<br>

-----------------------------------

## HTTP 커넥션 관리





