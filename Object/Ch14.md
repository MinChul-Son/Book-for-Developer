# 14. 일관성 있는 협력

객체에 **메시지**를 던져라.

객체는 **협력**을 위해 존재한다.

협력은 **객체 존재 이유와 문맥**을 제공한다.

협력을 바탕으로 잘 설계된 **애플리케이션은 이해가 쉬우며, 유지보수가 용이하며, 재사용이 쉬워진다**.

즉, 객체지향적 설계의 목표는 적절한 책임을 바탕으로한 객체들의 협력이다.

코드를 재사용하기 위해서는 객체들의 협력 방식을 일관성있게 만들어야한다.

<br>

## 일관성 없는 설계의 단점
- 비슷한 개념, 유사한 요구사항에서 각기 다른 방식으로 구현된다.
  - 시스템이 커질수록 코드를 이해하는데 매우 어려워진다.
  - 시스템이 커질수록 유지보수에 대한 비용이 눈덩이처럼 불어난다.

<br>
<br>

## 일관성있는 설계하기
- 풍부한 설계 경험, 디자인 패턴을 익히고 적용해보기
  - `Spring Framework`의 `Adapter Pattern`, `Singleton Pattern` 등

<br>
<br>

### 기본 지침
- **변하는 개념과 변하지 않는 개념으로부터 분리**
- **변하는 개념을 캡슐화**

<br>

이 기본 지침을 따르게되면 비슷한 개념, 유사한 요구사항에서 변하지 않는 부분에는 영향을 미치지 않고 변하는 부분만 고치거나 확장할 수 있게 된다.

객체지향에서는 객체가 다른 객체에게 메시지를 던진다.

이 때 메시지를 던지는 주체는 메시지를 받는 객체가 잘 처리해줄 것이라 믿고 메시지를 전송한다.

구체적인 방법은 메시지를 받는 객체 내부 로직에 따라 달라질 수 있다.

이 때 이 달라질 수 있는 부분을 인터페이스를 활용해 타입 계층으로 만들어 유연하게 설계할 수 있다.

이와 같이 타입 계층으로 클래스를 쪼개고나면 패턴이 생기고 일관성을 부여할 수 있게된다.

**인터페이스를 통해 타입 계층으로 분리된 유사한 클래스들은 추상화라는 거대한 개념으로 묶이게 되기 때문**이다.

**핵심은 추상화에 의존하게 하는 것이다.**

<br>

![image](https://user-images.githubusercontent.com/60773356/164244101-059741a0-56ff-4e93-8616-a6e9aab3c88e.png)
- `Spring Triangle`, `Spring Framework`의 가장 기본적인 유연한 구조가 바로 이 개념을 사용하고 있는 것이라는 생각이 듬

<br>

---

<br>
<br>

## 디자인 패턴으로 이해해보기

### 1-1. Template Method Pattern
![스크린샷 2022-04-20 오후 10 52 05](https://user-images.githubusercontent.com/60773356/164246006-fe1bf523-cf21-47c7-b577-a3e38a27c43f.png)

`Template Method Pattern`은 기준이 되는 템플릿이라는 틀을 사용하는 디자인 패턴이다.

템플릿에 변하지 않는 부분을 몰아넣고 변하는 부분은 추상 메서드를 자식 클래스에 별도로 오버라이딩하여 처리하는 방식이다.

간단한 코드로 살펴보자.

<br>

먼저, 기준이 될 추상 클래스인 템플릿을 정의한다.

<br>

![스크린샷 2022-04-20 오후 10 41 32](https://user-images.githubusercontent.com/60773356/164243767-2f09b5e1-6d31-4d95-9560-410b3238289f.png)

여기서 `logic`이라는 추상 메서드가 바로 변하는 부분이며 자식 클래스에서 오버라이딩되어 각자 다르게 처리될 로직을 의미한다.

<br>

![스크린샷 2022-04-20 오후 10 55 14](https://user-images.githubusercontent.com/60773356/164246650-728dafac-7c94-42b7-8698-80c47fc22a9a.png)

![스크린샷 2022-04-20 오후 10 56 04](https://user-images.githubusercontent.com/60773356/164247005-647c812b-f592-4956-9a2b-6a816538f4fe.png)

<br>

변하지 않는 부분과 변하는 부분을 분리하였고 최종적으로 앞으로 비슷한 개념에 대한 요구사항이 들어온다면 해당 템플릿을 상속하는 새로운 자식 클래스를 만들어 개별적으로 확장 및 처리가 가능하다.

<br>
<br>

### 1-2. Template Method Pattern의 단점
기본적으로 상속을 사용하기 때문에 상속이 가지는 단점을 모두 가지게 된다.
- 캡슐화 깨트림
- 부모 클래스에서의 영향이 자식에게도 모두 전파 등등

<br>

즉, **자식 클래스와 부모 클래스와 컴파일 시점에 강하게 결합**된다.

자식 클래스가 부모 클래스에게 상속받은 메서드를 사용하지 않더라도 강하게 의존한다.

사용하지 않더라도 부모 클래스를 알고있어야(의존)한다는 것은 좋은 설계이지 않을 수 있다.

<br>
<br>

---

<br>
<br>

### 2-1. Strategy Pattern
![스크린샷 2022-04-20 오후 11 09 07](https://user-images.githubusercontent.com/60773356/164249496-79008cfd-e5ce-4b41-8114-1b4dd58363d7.png)

전략 패턴은 변하지 않는 부분을 `Context`, 변하지 않는 부분을 `Strategy`라는 인터페이스를 만들어 문제를 해결한다.

즉, 상속이 아닌 **위임**을 사용하는 것이다.

이 방식을 통해 각각을 캡슐화하기 때문에 클라이언트와 독립적으로 로직을 변경할 수 있게 된다.

전략 패턴을 설명할 때 가장 흔하게 등장하는 자동차를 통해 코드로 살펴보자.

<br>

![스크린샷 2022-04-20 오후 11 19 48](https://user-images.githubusercontent.com/60773356/164251842-fe0aafa1-c756-4519-b7a3-8d2543362ab7.png)

먼저, 자동차를 움직이게 하는 엔진을 인터페이스로 만든다.

<br>

![스크린샷 2022-04-20 오후 11 20 43](https://user-images.githubusercontent.com/60773356/164252055-e5e2fa11-fce9-4c6e-a6cd-fb761175c102.png)

엔진 인터페이스를 구현하는 두개의 날 수 있는 엔진(`FlyableEngine`)과 앞으로만 가는 엔진(`ForwardEngine`)을 만들었다.

<br>

![스크린샷 2022-04-20 오후 11 21 55](https://user-images.githubusercontent.com/60773356/164252303-fa90a69d-8e06-4ab0-a33b-f0adce73cf39.png)

마지막으로 자동차를 만드는데 엔진을 가지게된다.

<br>

이 때 인터페이스(추상화)에 의존하고 있기 때문에 어떤 엔진이든 상관하지 않으며 해당 엔진이 `move()`를 잘 처리할 것이라 생각한다.

![스크린샷 2022-04-20 오후 11 23 16](https://user-images.githubusercontent.com/60773356/164252582-e03f624d-87ba-4699-b3ff-7b816e685d54.png)
![스크린샷 2022-04-20 오후 11 23 41](https://user-images.githubusercontent.com/60773356/164252681-765d59f0-515a-45bb-9da5-1ce1c4f96ba7.png)

상속이 아닌 **구현**을 사용하고 있기 때문에 변하지 않는 부분인 `Context`가 바뀌더라도 템플릿 메서드 패턴과는 달리 **아무 영향을 받지 않는다**.

<br>
<br>

### 2-2. Strategy Pattern의 단점
단점이라기 보다는 전략 패턴을 적용할 수 없는 상황이 존재할 수 있다.

위와 같은 방식에서는 생성 시점에 단 한번만 조립(주입)되기 때문에 해당 자동차를 앞으로만 가는 차로 생성하였다는 이후에는 변경할 수 없다.

또한, 확장성을 고려한다면 전략 패턴을 사용하는 것이 좋겠지만 만약 확장될 가능성이 진짜 절대 0%라면 분기를 타는 것이 더 좋은 코드가 될 수도 있다.

~~결국, 설계는 경험인가?..~~

<br>
<br>

### 2-3. Template Callback Pattern
조금 생소할 수도 있지만, 템플릿 콜백 패턴은 `GoF Design Pattern`이 아닌 `Spring Framework`에서 사용되는 전략 패턴의 변형 버전이다.

![스크린샷 2022-04-20 오후 11 36 34](https://user-images.githubusercontent.com/60773356/164255487-98ee35c4-4aa8-453f-a7c4-38b82f1835c1.png)
<br>

생성 시점에 주입받아 내부 상태로 들고 있는 것이 아닌 메서드 호출 시점에 인터페이스의 구현체를 넘겨주는 식으로 동작한다.

<br>

![스크린샷 2022-04-20 오후 11 37 45](https://user-images.githubusercontent.com/60773356/164255738-11700863-0822-4910-8f5e-733d7ce184ea.png)

이런식으로, 자동차의 생성 이후에 원하는 엔진으로 차를 주행시킬 수 있다.
<br>
<br>

---

<br>
<br>

### Proxy: Proxy Pattern & Decorator Pattern
프록시는 굉장히 넓은 개념으로 사용된다.

프록시 서버, 프록시 객체 등등

프록시라는 개념에서 핵심은 **대신하여 처리, 대체 가능**이다.

<br>

프록시를 사용하는 클라이언트의 입장에서는 **자신의 프록시를 사용하고 있는지 모른채 코드가 동작**되어야한다.

대체 가능, 사용자 입장에서 눈치채지 못하게 하기 위해서는 **프록시와 진짜 객체가 같은 인터페이스**를 사용해야한다.

<br>

프록시의 개념을 사용하는 디자인 패턴은 `Proxy Pattern`과 `Decorator Pattern`이 존재한다.

`GoF Design Pattern`에서는 이 두가지를 의도에 따라 나누고 있다.

<br>

**프록시 패턴 -> 접근 제어의 목적(캐싱, 지연 로딩 등)**

**데코레이터 패턴 -> 새로운 기능 추가의 목적(부가 기능)**

이를 적용시키면 원본 코드의 어떤 수정도 없이 원하는 기능을 추가할 수 있다.

<br>
<br>

클라이언트 - 서버 구조의 예시 코드를 작성해보자.

![스크린샷 2022-04-21 오전 12 04 43](https://user-images.githubusercontent.com/60773356/164261802-fc847e21-0c5f-4d4f-a0dc-a5bec9b5b34f.png)

먼저, 서버의 인터페이스를 정의한다.

<br>

![스크린샷 2022-04-21 오전 12 04 23](https://user-images.githubusercontent.com/60773356/164261752-37b4f754-5b0c-4570-a53b-a8c801b15e46.png)

클라이언트는 서버의 인터페이스를 의존하기 때문에 유연하게 어떤 구현체도 주입받을 수 있다.

<br>

![스크린샷 2022-04-21 오전 12 06 54](https://user-images.githubusercontent.com/60773356/164262332-988aae34-0ddb-4ffd-b353-328fe73238c2.png)

서버의 인터페이스를 구현한 진짜 서버이다.

<br>

![스크린샷 2022-04-21 오전 12 07 35](https://user-images.githubusercontent.com/60773356/164262480-d3d15e03-79ca-4757-a9b5-5b314fd840a2.png)

진짜 서버를 주입받게 되면 요청의 흐름은 **클라이언트 -> 서버**로 향하게 된다.

이 사이에 부가 기능을 하는 프록시 서버를 끼워넣어보자.

<br>

![스크린샷 2022-04-21 오전 12 08 39](https://user-images.githubusercontent.com/60773356/164262742-d39e28f4-dc5d-4209-b83f-401bc06734b1.png)

여기서 핵심은 프록시 서버 또한 서버의 인터페이스를 구현했으며 내부적으로 서버의 인터페이스를 주입받고 있는 점이다.

클라이언트 또한 서버의 인터페이스를 의존하고 있기 때문에 구현체가 프록시든 진짜 서버든 아무런 관심이 없다.

단순히 자신의 요청이 각 객체들간의 협력을 통해 잘 처리되기만 하면 되는 것이다.

<br>

![스크린샷 2022-04-21 오전 12 11 25](https://user-images.githubusercontent.com/60773356/164263429-c6e98778-abc7-49e6-bd7a-2cb6838a7ba0.png)

프록시 서버에 실제 서버를 주입하고 클라이언트가 프록시 서버에 의존하게 한다.

이렇게 되면 요청의 흐름은 **클라이언트 -> 프록시 서버 -> 서버**로 향하게 된다.

<br>

추가적인 부가 기능이 필요해 여러개의 프록시 서버가 필요하더라도 동일한 방식으로 프록시에 체인을 걸어 클라이언트나 내부 서버의 코드의 수정없이 확장이 가능해진 것이다.

<br>
<br>

---

<br>
<br>

## 캡슐화
**변경과 확장성에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴**을 얻을 수 있다.

캡슐화는 클래스의 모든 인스턴스 변수를 `private`로 선언해야하고 오직 해당 클래스의 메서드만이 인스턴스 변수에 접근할 수 있어야한다.

<br>

#### 캡슐화는 단순히 데이터를 감추는 것이 아닌 변할 수 있는 모든 개념을 감추는 것이다!

<br>

### 캡슐화의 종류
- 데이터 캡슐화: 모든 인스턴스 변수를 `private`
- 메서드 캡슐화: 메서드의 접근 레벨을 제어해 클래스 내부 또는 서브 클래스에서만 접근 가능하도록 캡슐화
- 객체 캡슐화: 객체와 객체 사이의 관계를 캡슐화 -> 합성(Composition)
- 서브타입 캡슐화: 추상화에 의존하게하여 클라이언트 코드가 구현체에 대해 알지 못하다록 캡슐화

<br>
<br>

## 개념적 무결성
유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 가장 효과적인 방법이다.

**시스템이 일관성있어진다면 이해하기 쉽고, 유지보수성과 확장성이 뛰어나게 된다.**

<br>
<br>

## 지속적인 개선
처음부터 완벽한 시스템은 없다.

오늘의 최선의 코드는 내일의 레거시이다.

미래를 예상할 수 없기 때문에 벌어지는 일들이다.

즉, 협력과 일관성은 고정된 것이 아니기 때문에 더 이상 변경의 무게를 지탱할 수 없다면 협력 패턴을 지속적으로 개선하고 과감한 리팩토링이 필요하다.

<br>
<br>

## 결론
**일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것이다.**

**유사한 기능에 대한 요구 사항이 계속 존재하고 변경이 지속적으로 발생한다면 캡슐화할 적절한 대상을 추상화하고 여기에 변하지 않는 공통적인 책임을 할당하라.**




